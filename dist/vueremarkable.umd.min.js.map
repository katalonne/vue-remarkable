{"version":3,"sources":["webpack://vueremarkable/webpack/universalModuleDefinition","webpack://vueremarkable/webpack/bootstrap","webpack://vueremarkable/./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js","webpack://vueremarkable/./node_modules/remarkable/dist/esm/index.browser.js","webpack://vueremarkable/./src/remarkable.js","webpack://vueremarkable/./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","window","document","currentScript","src","match","index_browser_textarea","decodeEntity","createElement","innerHTML","hasOwn","has","index_browser_assign","obj","sources","slice","arguments","forEach","source","TypeError","keys","UNESCAPE_MD_RE","unescapeMd","str","indexOf","replace","isValidEntityCode","fromCodePoint","surrogate1","surrogate2","String","fromCharCode","NAMED_ENTITY_RE","DIGITAL_ENTITY_TEST_RE","replaceEntityPattern","code","decoded","charCodeAt","test","toLowerCase","parseInt","replaceEntities","HTML_ESCAPE_TEST_RE","HTML_ESCAPE_REPLACE_RE","HTML_REPLACEMENTS","&","<",">","\"","replaceUnsafeChar","ch","escapeHtml","rules","nextToken","tokens","idx","length","type","tight","content","blockquote_open","blockquote_close","getBreak","block","fence","options","env","instance","fences","fenceName","highlighted","token","langClass","langPrefix","langName","params","split","join","fence_custom","highlight","apply","concat","heading_open","hLevel","heading_close","hr","xhtmlOut","bullet_list_open","bullet_list_close","list_item_open","list_item_close","ordered_list_open","order","ordered_list_close","paragraph_open","paragraph_close","addBreak","link_open","title","target","linkTarget","href","link_close","image","alt","suffix","table_open","table_close","thead_open","thead_close","tbody_open","tbody_close","tr_open","tr_close","th_open","align","th_close","td_open","td_close","strong_open","strong_close","em_open","em_close","del_open","del_close","ins_open","ins_close","mark_open","mark_close","sub","sup","hardbreak","softbreak","breaks","text","htmlblock","htmltag","abbr_open","abbr_close","footnote_ref","Number","id","toString","subId","footnote_block_open","footnote_block_close","footnote_open","footnote_close","footnote_anchor","dl_open","dt_open","dd_open","dl_close","dt_close","dd_close","Renderer","Ruler","__rules__","__cache__","state","inlineMode","push","trim","level","lines","children","parse","StateInline","parserInline","outTokens","parser","pos","posMax","pending","pendingLevel","cache","isInLabel","linkLevel","linkContent","labelUnmatchedScopes","parseLinkLabel","start","found","marker","labelEnd","max","oldPos","oldFlag","skipToken","parseAbbr","label","abbreviations","abbr","inline","normalizeLink","url","normalized","decodeURI","err","encodeURI","parseLinkDestination","link","validateLink","parseLinkTitle","normalizeReference","toUpperCase","parseReference","references","tok","footnote_block","j","lastParagraph","list","current","currentLabel","insideRef","refTokens","footnotes","filter","pop","count","renderInline","_rules","len","result","render","__find__","__compile__","chains","rule","enabled","altName","chain","fn","at","opt","Error","before","beforeName","ruleName","splice","after","afterName","enable","strict","Array","isArray","disable","getRules","chainName","pushPending","cacheSet","val","cacheGet","PUNCT_CHARS","regEscape","abbr2","nodes","reg","regText","blockTokens","abbrRegExp","map","x","substr","sort","a","b","RegExp","lastIndex","exec","index","RARE_RE","SCOPED_ABBR_RE","SCOPED_ABBR","tm","replaceScopedAbbr","inlineTokens","blkIdx","typographer","QUOTE_TEST_RE","QUOTE_RE","PUNCT_RE","APOSTROPHE","isLetter","replaceAt","smartquotes","thisLevel","lastSpace","nextSpace","item","canOpen","canClose","isSingle","stack","OUTER","single","quotes","Core","ruler","StateBlock","indent","indent_found","bMarks","eMarks","tShift","blkIndent","line","lineMax","parentType","ddIndent","startLine","endLine","nextLine","last","isEmpty","getLines","silent","mem","haveEndMarker","skipChars","skipSpaces","blockquote","lastLineEmpty","oldTShift","oldBMarks","oldIndent","oldParentType","terminatorRules","terminate","maxNesting","tokenize","cnt","skipBulletListMarker","skipOrderedListMarker","markTightParagraphs","oldTight","posAfterMarker","indentAfterMarker","markerValue","markerCharCode","isOrdered","contentStart","listTokIdx","prevEmptyEnd","listLines","itemLines","footnote","oldBMark","refs","heading","tmp","skipCharsBack","lheading","next","process","skipEmptyLines","from","min","begin","end","keepLastLF","first","queue","shift","Math","html_blocks","HTML_TAG_OPEN_RE","HTML_TAG_CLOSE_RE","isLetter$1","lc","html","getLine","table","lineText","rows","cell","aligns","tableLines","tbodyLines","substring","skipMarker","markTightParagraphs$1","deflist","ddLine","dtLine","oldDDIndent","paragraph","_rules$1","ParserBlock","ok","hasEmptyLines","TABS_SCAN_RE","NEWLINES_RE","SPACES_RE","isTerminatorChar","index_browser_text","newline","pmax","lineStart","lastTabPos","offset","ESCAPED","index_browser_i","index_browser_escape","backticks","matchStart","matchEnd","del","lastChar","nextChar","ins","mark","isAlphaNum","scanDelims","can_open","can_close","delims","emphasis","startCount","oldCount","newCount","res","UNESCAPE_RE","UNESCAPE_RE$1","links","labelStart","ref","isImage","footnote_inline","footnoteId","oldLength","footnoteSubId","url_schemas","EMAIL_RE","AUTOLINK_RE","autolink","tail","linkMatch","emailMatch","fullUrl","replace$1","regex","attr_name","unquoted","single_quoted","double_quoted","attr_value","attribute","open_tag","close_tag","comment","processing","declaration","cdata","HTML_TAG_RE","isLetter$2","DIGITAL_RE","NAMED_RE","entity","_rules$2","ParserInline","BAD_PROTOCOLS","cached_pos","defaultConfig","components","core","fullConfig","commonmarkConfig","config","default","full","commonmark","StateCore","renderer","Remarkable","preset","linkify","console","warn","configure","set","presets","use","plugin","parseInline","remarkable","props","className","container","data","md","undefined","methods","h","$createElement","domProps","renderMarkdown","$slots","textChildren","tag","markdownSlotText","reduce","acc","Container","class","__webpack_exports__"],"mappings":"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","file":"vueremarkable.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vueremarkable\"] = factory();\n\telse\n\t\troot[\"vueremarkable\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"fb15\");\n","// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var i\n  if ((i = window.document.currentScript) && (i = i.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/))) {\n    __webpack_public_path__ = i[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\nexport default null\n","var textarea;\n\nfunction decodeEntity(name) {\n  textarea = textarea || document.createElement('textarea');\n  textarea.innerHTML = '&' + name;\n  return textarea.value;\n}\n\n/**\n * Utility functions\n */\n\nfunction typeOf(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction isString(obj) {\n  return typeOf(obj) === '[object String]';\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return object\n    ? hasOwn.call(object, key)\n    : false;\n}\n\n// Extend objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = [].slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar UNESCAPE_MD_RE = /\\\\([\\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\nvar NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n  var decoded = decodeEntity(name);\n\n  if (name !== decoded) {\n    return decoded;\n  } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16)\n    :\n      parseInt(name.slice(1), 10);\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n  return match;\n}\n\nfunction replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  isString: isString,\n  has: has,\n  assign: assign,\n  unescapeMd: unescapeMd,\n  isValidEntityCode: isValidEntityCode,\n  fromCodePoint: fromCodePoint,\n  replaceEntities: replaceEntities,\n  escapeHtml: escapeHtml\n});\n\n/**\n * Renderer rules cache\n */\n\nvar rules = {};\n\n/**\n * Blockquotes\n */\n\nrules.blockquote_open = function(/* tokens, idx, options, env */) {\n  return '<blockquote>\\n';\n};\n\nrules.blockquote_close = function(tokens, idx /*, options, env */) {\n  return '</blockquote>' + getBreak(tokens, idx);\n};\n\n/**\n * Code\n */\n\nrules.code = function(tokens, idx /*, options, env */) {\n  if (tokens[idx].block) {\n    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);\n  }\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n\n/**\n * Fenced code blocks\n */\n\nrules.fence = function(tokens, idx, options, env, instance) {\n  var token = tokens[idx];\n  var langClass = '';\n  var langPrefix = options.langPrefix;\n  var langName = '', fences, fenceName;\n  var highlighted;\n\n  if (token.params) {\n\n    //\n    // ```foo bar\n    //\n    // Try custom renderer \"foo\" first. That will simplify overwrite\n    // for diagrams, latex, and any other fenced block with custom look\n    //\n\n    fences = token.params.split(/\\s+/g);\n    fenceName = fences.join(' ');\n\n    if (has(instance.rules.fence_custom, fences[0])) {\n      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);\n    }\n\n    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\n    langClass = ' class=\"' + langPrefix + langName + '\"';\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight.apply(options.highlight, [ token.content ].concat(fences))\n      || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  return '<pre><code' + langClass + '>'\n        + highlighted\n        + '</code></pre>'\n        + getBreak(tokens, idx);\n};\n\nrules.fence_custom = {};\n\n/**\n * Headings\n */\n\nrules.heading_open = function(tokens, idx /*, options, env */) {\n  return '<h' + tokens[idx].hLevel + '>';\n};\nrules.heading_close = function(tokens, idx /*, options, env */) {\n  return '</h' + tokens[idx].hLevel + '>\\n';\n};\n\n/**\n * Horizontal rules\n */\n\nrules.hr = function(tokens, idx, options /*, env */) {\n  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);\n};\n\n/**\n * Bullets\n */\n\nrules.bullet_list_open = function(/* tokens, idx, options, env */) {\n  return '<ul>\\n';\n};\nrules.bullet_list_close = function(tokens, idx /*, options, env */) {\n  return '</ul>' + getBreak(tokens, idx);\n};\n\n/**\n * List items\n */\n\nrules.list_item_open = function(/* tokens, idx, options, env */) {\n  return '<li>';\n};\nrules.list_item_close = function(/* tokens, idx, options, env */) {\n  return '</li>\\n';\n};\n\n/**\n * Ordered list items\n */\n\nrules.ordered_list_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  var order = token.order > 1 ? ' start=\"' + token.order + '\"' : '';\n  return '<ol' + order + '>\\n';\n};\nrules.ordered_list_close = function(tokens, idx /*, options, env */) {\n  return '</ol>' + getBreak(tokens, idx);\n};\n\n/**\n * Paragraphs\n */\n\nrules.paragraph_open = function(tokens, idx /*, options, env */) {\n  return tokens[idx].tight ? '' : '<p>';\n};\nrules.paragraph_close = function(tokens, idx /*, options, env */) {\n  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);\n  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');\n};\n\n/**\n * Links\n */\n\nrules.link_open = function(tokens, idx, options /* env */) {\n  var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n  var target = options.linkTarget ? (' target=\"' + options.linkTarget + '\"') : '';\n  return '<a href=\"' + escapeHtml(tokens[idx].href) + '\"' + title + target + '>';\n};\nrules.link_close = function(/* tokens, idx, options, env */) {\n  return '</a>';\n};\n\n/**\n * Images\n */\n\nrules.image = function(tokens, idx, options /*, env */) {\n  var src = ' src=\"' + escapeHtml(tokens[idx].src) + '\"';\n  var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n  var alt = ' alt=\"' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '\"';\n  var suffix = options.xhtmlOut ? ' /' : '';\n  return '<img' + src + alt + title + suffix + '>';\n};\n\n/**\n * Tables\n */\n\nrules.table_open = function(/* tokens, idx, options, env */) {\n  return '<table>\\n';\n};\nrules.table_close = function(/* tokens, idx, options, env */) {\n  return '</table>\\n';\n};\nrules.thead_open = function(/* tokens, idx, options, env */) {\n  return '<thead>\\n';\n};\nrules.thead_close = function(/* tokens, idx, options, env */) {\n  return '</thead>\\n';\n};\nrules.tbody_open = function(/* tokens, idx, options, env */) {\n  return '<tbody>\\n';\n};\nrules.tbody_close = function(/* tokens, idx, options, env */) {\n  return '</tbody>\\n';\n};\nrules.tr_open = function(/* tokens, idx, options, env */) {\n  return '<tr>';\n};\nrules.tr_close = function(/* tokens, idx, options, env */) {\n  return '</tr>\\n';\n};\nrules.th_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<th'\n    + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n    + '>';\n};\nrules.th_close = function(/* tokens, idx, options, env */) {\n  return '</th>';\n};\nrules.td_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<td'\n    + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n    + '>';\n};\nrules.td_close = function(/* tokens, idx, options, env */) {\n  return '</td>';\n};\n\n/**\n * Bold\n */\n\nrules.strong_open = function(/* tokens, idx, options, env */) {\n  return '<strong>';\n};\nrules.strong_close = function(/* tokens, idx, options, env */) {\n  return '</strong>';\n};\n\n/**\n * Italicize\n */\n\nrules.em_open = function(/* tokens, idx, options, env */) {\n  return '<em>';\n};\nrules.em_close = function(/* tokens, idx, options, env */) {\n  return '</em>';\n};\n\n/**\n * Strikethrough\n */\n\nrules.del_open = function(/* tokens, idx, options, env */) {\n  return '<del>';\n};\nrules.del_close = function(/* tokens, idx, options, env */) {\n  return '</del>';\n};\n\n/**\n * Insert\n */\n\nrules.ins_open = function(/* tokens, idx, options, env */) {\n  return '<ins>';\n};\nrules.ins_close = function(/* tokens, idx, options, env */) {\n  return '</ins>';\n};\n\n/**\n * Highlight\n */\n\nrules.mark_open = function(/* tokens, idx, options, env */) {\n  return '<mark>';\n};\nrules.mark_close = function(/* tokens, idx, options, env */) {\n  return '</mark>';\n};\n\n/**\n * Super- and sub-script\n */\n\nrules.sub = function(tokens, idx /*, options, env */) {\n  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';\n};\nrules.sup = function(tokens, idx /*, options, env */) {\n  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';\n};\n\n/**\n * Breaks\n */\n\nrules.hardbreak = function(tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\nrules.softbreak = function(tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n/**\n * Text\n */\n\nrules.text = function(tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n/**\n * Content\n */\n\nrules.htmlblock = function(tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\nrules.htmltag = function(tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n/**\n * Abbreviations, initialism\n */\n\nrules.abbr_open = function(tokens, idx /*, options, env */) {\n  return '<abbr title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\">';\n};\nrules.abbr_close = function(/* tokens, idx, options, env */) {\n  return '</abbr>';\n};\n\n/**\n * Footnotes\n */\n\nrules.footnote_ref = function(tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n};\nrules.footnote_block_open = function(tokens, idx, options) {\n  var hr = options.xhtmlOut\n    ? '<hr class=\"footnotes-sep\" />\\n'\n    : '<hr class=\"footnotes-sep\">\\n';\n  return hr + '<section class=\"footnotes\">\\n<ol class=\"footnotes-list\">\\n';\n};\nrules.footnote_block_close = function() {\n  return '</ol>\\n</section>\\n';\n};\nrules.footnote_open = function(tokens, idx) {\n  var id = Number(tokens[idx].id + 1).toString();\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n};\nrules.footnote_close = function() {\n  return '</li>\\n';\n};\nrules.footnote_anchor = function(tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">↩</a>';\n};\n\n/**\n * Definition lists\n */\n\nrules.dl_open = function() {\n  return '<dl>\\n';\n};\nrules.dt_open = function() {\n  return '<dt>';\n};\nrules.dd_open = function() {\n  return '<dd>';\n};\nrules.dl_close = function() {\n  return '</dl>\\n';\n};\nrules.dt_close = function() {\n  return '</dt>\\n';\n};\nrules.dd_close = function() {\n  return '</dd>\\n';\n};\n\n/**\n * Helper functions\n */\n\nfunction nextToken(tokens, idx) {\n  if (++idx >= tokens.length - 2) {\n    return idx;\n  }\n  if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&\n      (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&\n      (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {\n    return nextToken(tokens, idx + 2);\n  }\n  return idx;\n}\n\n/**\n * Check to see if `\\n` is needed before the next token.\n *\n * @param  {Array} `tokens`\n * @param  {Number} `idx`\n * @return {String} Empty string or newline\n * @api private\n */\n\nvar getBreak = rules.getBreak = function getBreak(tokens, idx) {\n  idx = nextToken(tokens, idx);\n  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {\n    return '';\n  }\n  return '\\n';\n};\n\n/**\n * Renderer class. Renders HTML and exposes `rules` to allow\n * local modifications.\n */\n\nfunction Renderer() {\n  this.rules = assign({}, rules);\n\n  // exported helper, for custom rules only\n  this.getBreak = rules.getBreak;\n}\n\n/**\n * Render a string of inline HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length, i = 0;\n  var result = '';\n\n  while (len--) {\n    result += _rules[tokens[i].type](tokens, i++, options, env, this);\n  }\n\n  return result;\n};\n\n/**\n * Render a string of HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.render = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length, i = -1;\n  var result = '';\n\n  while (++i < len) {\n    if (tokens[i].type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else {\n      result += _rules[tokens[i].type](tokens, i, options, env, this);\n    }\n  }\n  return result;\n};\n\n/**\n * Ruler is a helper class for building responsibility chains from\n * parse rules. It allows:\n *\n *   - easy stack rules chains\n *   - getting main chain and named chains content (as arrays of functions)\n *\n * Helper methods, should not be used directly.\n * @api private\n */\n\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // { name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ] }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - digital anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n/**\n * Find the index of a rule by `name`.\n *\n * @param  {String} `name`\n * @return {Number} Index of the given `name`\n * @api private\n */\n\nRuler.prototype.__find__ = function (name) {\n  var len = this.__rules__.length;\n  var i = -1;\n\n  while (len--) {\n    if (this.__rules__[++i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Build the rules lookup cache\n *\n * @api private\n */\n\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n/**\n * Ruler public methods\n * ------------------------------------------------\n */\n\n/**\n * Replace rule function\n *\n * @param  {String} `name` Rule name\n * @param  {Function `fn`\n * @param  {Object} `options`\n * @api private\n */\n\nRuler.prototype.at = function (name, fn, options) {\n  var idx = this.__find__(name);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n\n  this.__rules__[idx].fn = fn;\n  this.__rules__[idx].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain before given the `ruleName`.\n *\n * @param  {String}   `beforeName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var idx = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n\n  this.__rules__.splice(idx, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain after the given `ruleName`.\n *\n * @param  {String}   `afterName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var idx = this.__find__(afterName);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n\n  this.__rules__.splice(idx + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the end of chain.\n *\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @return {String}\n */\n\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Enable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to enable\n * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.\n * @api private\n */\n\nRuler.prototype.enable = function (list, strict) {\n  list = !Array.isArray(list)\n    ? [ list ]\n    : list;\n\n  // In strict mode disable all existing rules first\n  if (strict) {\n    this.__rules__.forEach(function (rule) {\n      rule.enabled = false;\n    });\n  }\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n  }, this);\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Disable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to disable\n * @api private\n */\n\nRuler.prototype.disable = function (list) {\n  list = !Array.isArray(list)\n    ? [ list ]\n    : list;\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n  }, this);\n\n  this.__cache__ = null;\n};\n\n/**\n * Get a rules list as an array of functions.\n *\n * @param  {String} `chainName`\n * @return {Object}\n * @api private\n */\n\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n  return this.__cache__[chainName] || [];\n};\n\nfunction block(state) {\n\n  if (state.inlineMode) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.replace(/\\n/g, ' ').trim(),\n      level: 0,\n      lines: [ 0, 1 ],\n      children: []\n    });\n\n  } else {\n    state.block.parse(state.src, state.options, state.env, state.tokens);\n  }\n}\n\n// Inline parser state\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n                          // \"paired\" rules (emphasis, strikes) to not skip\n                          // tailing `]`\n\n  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent\n                          // nesting in definitions\n\n  this.linkContent = '';  // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n                                 // (backtrack optimization)\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n};\n\n// Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n};\n\n// Get cache value\n//\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\nfunction parseLinkLabel(state, start) {\n  var level, found, marker,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos,\n      oldFlag = state.isInLabel;\n\n  if (state.isInLabel) { return -1; }\n\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5B /* [ */) {\n      level++;\n    } else if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n\n  return labelEnd;\n}\n\n// Parse abbreviation definitions, i.e. `*[abbr]: description`\n\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }\n  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // abbr title is always one line, so looking for ending \"\\n\" here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) { break; }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n  if (title.length === 0) { return -1; }\n  if (!env.abbreviations) { env.abbreviations = {}; }\n  // prepend ':' to avoid conflict with Object.prototype members\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nfunction abbr(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Parse inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i].type === 'inline' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction normalizeLink(url) {\n  var normalized = replaceEntities(url);\n  // We shouldn't care about the result of malformed URIs,\n  // and should not throw an exception.\n  try {\n    normalized = decodeURI(normalized);\n  } catch (err) {}\n  return encodeURI(normalized);\n}\n\n/**\n * Parse link destination\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkDestination(state, pos) {\n  var code, level, link,\n      start = pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = state.src.charCodeAt(pos);\n      if (code === 0x0A /* \\n */) { return false; }\n      if (code === 0x3E /* > */) {\n        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\n        if (!state.parser.validateLink(link)) { return false; }\n        state.pos = pos + 1;\n        state.linkContent = link;\n        return true;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n\n      pos++;\n    }\n\n    // no closing '>'\n    return false;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n\n    if (code === 0x20) { break; }\n\n    // ascii control chars\n    if (code < 0x20 || code === 0x7F) { break; }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++;\n      if (level > 1) { break; }\n    }\n\n    if (code === 0x29 /* ) */) {\n      level--;\n      if (level < 0) { break; }\n    }\n\n    pos++;\n  }\n\n  if (start === pos) { return false; }\n\n  link = unescapeMd(state.src.slice(start, pos));\n  if (!state.parser.validateLink(link)) { return false; }\n\n  state.linkContent = link;\n  state.pos = pos;\n  return true;\n}\n\n/**\n * Parse link title\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkTitle(state, pos) {\n  var code,\n      start = pos,\n      max = state.posMax,\n      marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }\n\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) { marker = 0x29; }\n\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n    if (code === marker) {\n      state.pos = pos + 1;\n      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\n      return true;\n    }\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    pos++;\n  }\n\n  return false;\n}\n\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  if (!parseLinkDestination(state, pos)) { return -1; }\n  href = state.linkContent;\n  pos = state.pos;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  }\n\n  // ensure that the end of the line is empty\n  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = { title: title, href: href };\n  }\n\n  return pos;\n}\n\n\nfunction references(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Scan definitions in paragraph inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' &&\n        tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.inline.parse(tok.content, state.options, state.env, tok.children);\n    }\n  }\n}\n\nfunction footnote_block(state) {\n  var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,\n      level = 0,\n      insideRef = false,\n      refTokens = {};\n\n  if (!state.env.footnotes) { return; }\n\n  state.tokens = state.tokens.filter(function(tok) {\n    if (tok.type === 'footnote_reference_open') {\n      insideRef = true;\n      current = [];\n      currentLabel = tok.label;\n      return false;\n    }\n    if (tok.type === 'footnote_reference_close') {\n      insideRef = false;\n      // prepend ':' to avoid conflict with Object.prototype members\n      refTokens[':' + currentLabel] = current;\n      return false;\n    }\n    if (insideRef) { current.push(tok); }\n    return !insideRef;\n  });\n\n  if (!state.env.footnotes.list) { return; }\n  list = state.env.footnotes.list;\n\n  state.tokens.push({\n    type: 'footnote_block_open',\n    level: level++\n  });\n  for (i = 0, l = list.length; i < l; i++) {\n    state.tokens.push({\n      type: 'footnote_open',\n      id: i,\n      level: level++\n    });\n\n    if (list[i].tokens) {\n      tokens = [];\n      tokens.push({\n        type: 'paragraph_open',\n        tight: false,\n        level: level++\n      });\n      tokens.push({\n        type: 'inline',\n        content: '',\n        level: level,\n        children: list[i].tokens\n      });\n      tokens.push({\n        type: 'paragraph_close',\n        tight: false,\n        level: --level\n      });\n    } else if (list[i].label) {\n      tokens = refTokens[':' + list[i].label];\n    }\n\n    state.tokens = state.tokens.concat(tokens);\n    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n      lastParagraph = state.tokens.pop();\n    } else {\n      lastParagraph = null;\n    }\n\n    t = list[i].count > 0 ? list[i].count : 1;\n    for (j = 0; j < t; j++) {\n      state.tokens.push({\n        type: 'footnote_anchor',\n        id: i,\n        subId: j,\n        level: level\n      });\n    }\n\n    if (lastParagraph) {\n      state.tokens.push(lastParagraph);\n    }\n\n    state.tokens.push({\n      type: 'footnote_close',\n      level: --level\n    });\n  }\n  state.tokens.push({\n    type: 'footnote_block_close',\n    level: --level\n  });\n}\n\n// Enclose abbreviations in <abbr> tags\n//\n\nvar PUNCT_CHARS = ' \\n()[]\\'\".,!?-';\n\n\n// from Google closure library\n// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021\nfunction regEscape(s) {\n  return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1');\n}\n\n\nfunction abbr2(state) {\n  var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,\n      blockTokens = state.tokens;\n\n  if (!state.env.abbreviations) { return; }\n  if (!state.env.abbrRegExp) {\n    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'\n            + '(' + Object.keys(state.env.abbreviations).map(function (x) {\n                      return x.substr(1);\n                    }).sort(function (a, b) {\n                      return b.length - a.length;\n                    }).map(regEscape).join('|') + ')'\n            + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';\n    state.env.abbrRegExp = new RegExp(regText, 'g');\n  }\n  reg = state.env.abbrRegExp;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') { continue; }\n    tokens = blockTokens[j].children;\n\n    // We scan from the end, to keep position when new tags added.\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n      if (token.type !== 'text') { continue; }\n\n      pos = 0;\n      text = token.content;\n      reg.lastIndex = 0;\n      level = token.level;\n      nodes = [];\n\n      while ((m = reg.exec(text))) {\n        if (reg.lastIndex > pos) {\n          nodes.push({\n            type: 'text',\n            content: text.slice(pos, m.index + m[1].length),\n            level: level\n          });\n        }\n\n        nodes.push({\n          type: 'abbr_open',\n          title: state.env.abbreviations[':' + m[2]],\n          level: level++\n        });\n        nodes.push({\n          type: 'text',\n          content: m[2],\n          level: level\n        });\n        nodes.push({\n          type: 'abbr_close',\n          level: --level\n        });\n        pos = reg.lastIndex - m[3].length;\n      }\n\n      if (!nodes.length) { continue; }\n\n      if (pos < text.length) {\n        nodes.push({\n          type: 'text',\n          content: text.slice(pos),\n          level: level\n        });\n      }\n\n      // replace current node\n      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n    }\n  }\n}\n\n// Simple typographical replacements\n//\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  'c': '©',\n  'r': '®',\n  'p': '§',\n  'tm': '™'\n};\n\nfunction replaceScopedAbbr(str) {\n  if (str.indexOf('(') < 0) { return str; }\n\n  return str.replace(SCOPED_ABBR_RE, function(match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  });\n}\n\n\nfunction replace(state) {\n  var i, token, text, inlineTokens, blkIdx;\n\n  if (!state.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    inlineTokens = state.tokens[blkIdx].children;\n\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n      if (token.type === 'text') {\n        text = token.content;\n\n        text = replaceScopedAbbr(text);\n\n        if (RARE_RE.test(text)) {\n          text = text\n            .replace(/\\+-/g, '±')\n            // .., ..., ....... -> …\n            // but ?..... & !..... -> ?.. & !..\n            .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..')\n            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n            // em-dash\n            .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n            // en-dash\n            .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\n            .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n        }\n\n        token.content = text;\n      }\n    }\n  }\n}\n\n// Convert straight quotation marks to typographic ones\n//\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar PUNCT_RE = /[-\\s()\\[\\]]/;\nvar APOSTROPHE = '’';\n\n// This function returns true if the character at `pos`\n// could be inside a word.\nfunction isLetter(str, pos) {\n  if (pos < 0 || pos >= str.length) { return false; }\n  return !PUNCT_RE.test(str[pos]);\n}\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\n\nfunction smartquotes(state) {\n  /*eslint max-depth:0*/\n  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,\n      canOpen, canClose, j, isSingle, blkIdx, tokens,\n      stack;\n\n  if (!state.options.typographer) { return; }\n\n  stack = [];\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    tokens = state.tokens[blkIdx].children;\n    stack.length = 0;\n\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n\n      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }\n\n      thisLevel = tokens[i].level;\n\n      for (j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].level <= thisLevel) { break; }\n      }\n      stack.length = j + 1;\n\n      text = token.content;\n      pos = 0;\n      max = text.length;\n\n      /*eslint no-labels:0,block-scoped-var:0*/\n      OUTER:\n      while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t = QUOTE_RE.exec(text);\n        if (!t) { break; }\n\n        lastSpace = !isLetter(text, t.index - 1);\n        pos = t.index + 1;\n        isSingle = (t[0] === \"'\");\n        nextSpace = !isLetter(text, pos);\n\n        if (!nextSpace && !lastSpace) {\n          // middle of word\n          if (isSingle) {\n            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n          }\n          continue;\n        }\n\n        canOpen = !nextSpace;\n        canClose = !lastSpace;\n\n        if (canClose) {\n          // this could be a closing quote, rewind the stack to get a match\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n            if (stack[j].level < thisLevel) { break; }\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n              if (isSingle) {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\n              } else {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\n              }\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Core parser `rules`\n */\n\nvar _rules = [\n  [ 'block',          block          ],\n  [ 'abbr',           abbr           ],\n  [ 'references',     references     ],\n  [ 'inline',         inline         ],\n  [ 'footnote_tail',  footnote_block  ],\n  [ 'abbr2',          abbr2          ],\n  [ 'replacements',   replace   ],\n  [ 'smartquotes',    smartquotes    ],\n];\n\n/**\n * Class for top level (`core`) parser rules\n *\n * @api private\n */\n\nfunction Core() {\n  this.options = {};\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n/**\n * Process rules with the given `state`\n *\n * @param  {Object} `state`\n * @api private\n */\n\nCore.prototype.process = function (state) {\n  var i, l, rules;\n  rules = this.ruler.getRules('');\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\n// Parser state class\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n\n  this.src = src;\n\n  // Shortcuts to simplify nested calls\n  this.parser = parser;\n\n  this.options = options;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // indent for each line\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20/* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, first, last, queue, shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) { shift = indent; }\n    if (shift < 0) { shift = 0; }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\n// Code block (4 spaces padded)\n\nfunction code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last;\n\n  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'code',\n    content: state.getLines(startLine, last, 4 + state.blkIndent, true),\n    block: true,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// fences (``` lang, ~~~ lang)\n\nfunction fences(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  params = state.src.slice(pos, max).trim();\n\n  if (params.indexOf('`') >= 0) { return false; }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.tShift[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// Block quotes\n\nfunction blockquote(state, startLine, endLine, silent) {\n  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\n      terminatorRules,\n      i, l, terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  // check if we have an empty blockquote\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.parser.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n\n    // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n}\n\n// Horizontal rule\n\nfunction hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine];\n\n  pos += state.tShift[startLine];\n\n  if (pos > max) { return false; }\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 one\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && ch !== 0x20/* space */) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'hr',\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// Lists\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) { return -1; }\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\n\nfunction list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i, l, terminate;\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n  }\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n    if (indentAfterMarker < 1) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;\n\n    // Run subparser & write tokens\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n\n    state.parser.tokenize(state, startLine, endLine, true);\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n}\n\n// Process footnote reference list\n\nfunction footnote(state, startLine, endLine, silent) {\n  var oldBMark, oldTShift, oldParentType, pos, label,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // line should be at least 5 chars - \"[^x]:\"\n  if (start + 4 > max) { return false; }\n\n  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) { return false; }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n\n  if (pos === start + 2) { return false; } // no empty footnote labels\n  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n  if (silent) { return true; }\n  pos++;\n\n  if (!state.env.footnotes) { state.env.footnotes = {}; }\n  if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n  label = state.src.slice(start + 2, pos - 2);\n  state.env.footnotes.refs[':' + label] = -1;\n\n  state.tokens.push({\n    type: 'footnote_reference_open',\n    label: label,\n    level: state.level++\n  });\n\n  oldBMark = state.bMarks[startLine];\n  oldTShift = state.tShift[startLine];\n  oldParentType = state.parentType;\n  state.tShift[startLine] = state.skipSpaces(pos) - pos;\n  state.bMarks[startLine] = pos;\n  state.blkIndent += 4;\n  state.parentType = 'footnote';\n\n  if (state.tShift[startLine] < state.blkIndent) {\n    state.tShift[startLine] += state.blkIndent;\n    state.bMarks[startLine] -= state.blkIndent;\n  }\n\n  state.parser.tokenize(state, startLine, endLine, true);\n\n  state.parentType = oldParentType;\n  state.blkIndent -= 4;\n  state.tShift[startLine] = oldTShift;\n  state.bMarks[startLine] = oldBMark;\n\n  state.tokens.push({\n    type: 'footnote_reference_close',\n    level: --state.level\n  });\n\n  return true;\n}\n\n// heading (#, ##, ...)\n\nfunction heading(state, startLine, endLine, silent) {\n  var ch, level, tmp,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos >= max) { return false; }\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipCharsBack(max, 0x20, pos); // space\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  state.tokens.push({ type: 'heading_open',\n    hLevel: level,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  // only if header is not empty\n  if (pos < max) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.slice(pos, max).trim(),\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n  }\n  state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });\n\n  return true;\n}\n\n// lheading (---, ===)\n\nfunction lheading(state, startLine, endLine/*, silent*/) {\n  var marker, pos, max,\n      next = startLine + 1;\n\n  if (next >= endLine) { return false; }\n  if (state.tShift[next] < state.blkIndent) { return false; }\n\n  // Scan next line\n\n  if (state.tShift[next] - state.blkIndent > 3) { return false; }\n\n  pos = state.bMarks[next] + state.tShift[next];\n  max = state.eMarks[next];\n\n  if (pos >= max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }\n\n  pos = state.skipChars(pos, marker);\n\n  pos = state.skipSpaces(pos);\n\n  if (pos < max) { return false; }\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n\n  state.line = next + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: marker === 0x3D/* = */ ? 1 : 2,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n  state.tokens.push({\n    type: 'inline',\n    content: state.src.slice(pos, state.eMarks[startLine]).trim(),\n    level: state.level + 1,\n    lines: [ startLine, state.line - 1 ],\n    children: []\n  });\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: marker === 0x3D/* = */ ? 1 : 2,\n    level: state.level\n  });\n\n  return true;\n}\n\n// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\nvar html_blocks = {};\n\n[\n  'article',\n  'aside',\n  'button',\n  'blockquote',\n  'body',\n  'canvas',\n  'caption',\n  'col',\n  'colgroup',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'iframe',\n  'li',\n  'map',\n  'object',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'progress',\n  'script',\n  'section',\n  'style',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'tr',\n  'thead',\n  'ul',\n  'video'\n].forEach(function (name) { html_blocks[name] = true; });\n\n// HTML block\n\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\nfunction isLetter$1(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\nfunction htmlblock(state, startLine, endLine, silent) {\n  var ch, match, nextLine,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine],\n      shift = state.tShift[startLine];\n\n  pos += shift;\n\n  if (!state.options.html) { return false; }\n\n  if (shift > 3 || pos + 2 >= max) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {\n    // Directive start / comment start / processing instruction start\n    if (silent) { return true; }\n\n  } else if (ch === 0x2F/* / */ || isLetter$1(ch)) {\n\n    // Probably start or end of tag\n    if (ch === 0x2F/* \\ */) {\n      // closing tag\n      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n      if (!match) { return false; }\n    } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n      if (!match) { return false; }\n    }\n    // Make sure tag name is valid\n    if (html_blocks[match[1].toLowerCase()] !== true) { return false; }\n    if (silent) { return true; }\n\n  } else {\n    return false;\n  }\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n  nextLine = startLine + 1;\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [ startLine, state.line ],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n\n  return true;\n}\n\n// GFM table, non-standard\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n\n  return state.src.substr(pos, max - pos);\n}\n\nfunction table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, rows, cell,\n      aligns, t, tableLines, tbodyLines;\n\n  // should have at least three lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n\n  // first character of the second line should be '|' or '-'\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  ch = state.src.charCodeAt(pos);\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n  lineText = getLine(state, startLine + 1);\n  if (!/^[-:| ]+$/.test(lineText)) { return false; }\n\n  rows = lineText.split('|');\n  if (rows <= 2) { return false; }\n  aligns = [];\n  for (i = 0; i < rows.length; i++) {\n    t = rows[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === rows.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n  if (aligns.length !== rows.length) { return false; }\n  if (silent) { return true; }\n\n  state.tokens.push({\n    type: 'table_open',\n    lines: tableLines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'thead_open',\n    lines: [ startLine, startLine + 1 ],\n    level: state.level++\n  });\n\n  state.tokens.push({\n    type: 'tr_open',\n    lines: [ startLine, startLine + 1 ],\n    level: state.level++\n  });\n  for (i = 0; i < rows.length; i++) {\n    state.tokens.push({\n      type: 'th_open',\n      align: aligns[i],\n      lines: [ startLine, startLine + 1 ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: rows[i].trim(),\n      lines: [ startLine, startLine + 1 ],\n      level: state.level,\n      children: []\n    });\n    state.tokens.push({ type: 'th_close', level: --state.level });\n  }\n  state.tokens.push({ type: 'tr_close', level: --state.level });\n  state.tokens.push({ type: 'thead_close', level: --state.level });\n\n  state.tokens.push({\n    type: 'tbody_open',\n    lines: tbodyLines = [ startLine + 2, 0 ],\n    level: state.level++\n  });\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    lineText = getLine(state, nextLine).trim();\n    if (lineText.indexOf('|') === -1) { break; }\n    rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n\n    state.tokens.push({ type: 'tr_open', level: state.level++ });\n    for (i = 0; i < rows.length; i++) {\n      state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });\n      // 0x7c === '|'\n      cell = rows[i].substring(\n          rows[i].charCodeAt(0) === 0x7c ? 1 : 0,\n          rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length\n      ).trim();\n      state.tokens.push({\n        type: 'inline',\n        content: cell,\n        level: state.level,\n        children: []\n      });\n      state.tokens.push({ type: 'td_close', level: --state.level });\n    }\n    state.tokens.push({ type: 'tr_close', level: --state.level });\n  }\n  state.tokens.push({ type: 'tbody_close', level: --state.level });\n  state.tokens.push({ type: 'table_close', level: --state.level });\n\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n}\n\n// Definition lists\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipMarker(state, line) {\n  var pos, marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) { return -1; }\n\n  // Check bullet\n  marker = state.src.charCodeAt(start++);\n  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n  pos = state.skipSpaces(start);\n\n  // require space after \":\"\n  if (start === pos) { return -1; }\n\n  // no empty definitions, e.g. \"  : \"\n  if (pos >= max) { return -1; }\n\n  return pos;\n}\n\nfunction markTightParagraphs$1(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nfunction deflist(state, startLine, endLine, silent) {\n  var contentStart,\n      ddLine,\n      dtLine,\n      itemLines,\n      listLines,\n      listTokIdx,\n      nextLine,\n      oldIndent,\n      oldDDIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      prevEmptyEnd,\n      tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) { return false; }\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) { return false; }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n  contentStart = skipMarker(state, nextLine);\n  if (contentStart < 0) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [ startLine, 0 ],\n    level: state.level++\n  });\n\n  //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  /*eslint no-labels:0,block-scoped-var:0*/\n  OUTER:\n  for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [ dtLine, dtLine ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [ dtLine, dtLine ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [ nextLine, 0 ],\n        level: state.level++\n      });\n\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n\n      state.parser.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) { break OUTER; }\n\n      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }\n      contentStart = skipMarker(state, nextLine);\n      if (contentStart < 0) { break; }\n\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) { break; }\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) { break; }\n    if (state.tShift[dtLine] < state.blkIndent) { break; }\n\n    ddLine = dtLine + 1;\n    if (ddLine >= endLine) { break; }\n    if (state.isEmpty(ddLine)) { ddLine++; }\n    if (ddLine >= endLine) { break; }\n\n    if (state.tShift[ddLine] < state.blkIndent) { break; }\n    contentStart = skipMarker(state, ddLine);\n    if (contentStart < 0) { break; }\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs$1(state, listTokIdx);\n  }\n\n  return true;\n}\n\n// Paragraph\n\nfunction paragraph(state, startLine/*, endLine*/) {\n  var endLine, content, terminate, i, l,\n      nextLine = startLine + 1,\n      terminatorRules;\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\n\n      // Some tags can terminate paragraph without empty line.\n      terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) { break; }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [ startLine, state.line ],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n}\n\n/**\n * Parser rules\n */\n\nvar _rules$1 = [\n  [ 'code',       code ],\n  [ 'fences',     fences,     [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'blockquote', blockquote, [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'hr',         hr,         [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'list',       list,       [ 'paragraph', 'blockquote' ] ],\n  [ 'footnote',   footnote,   [ 'paragraph' ] ],\n  [ 'heading',    heading,    [ 'paragraph', 'blockquote' ] ],\n  [ 'lheading',   lheading ],\n  [ 'htmlblock',  htmlblock,  [ 'paragraph', 'blockquote' ] ],\n  [ 'table',      table,      [ 'paragraph' ] ],\n  [ 'deflist',    deflist,    [ 'paragraph' ] ],\n  [ 'paragraph',  paragraph ]\n];\n\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$1.length; i++) {\n    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {\n      alt: (_rules$1[i][2] || []).slice()\n    });\n  }\n}\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        break;\n      }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE    = /\\u00a0/g;\n\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state, lineStart = 0, lastTabPos = 0;\n  if (!str) { return []; }\n\n  // Normalize spaces\n  str = str.replace(SPACES_RE, ' ');\n\n  // Normalize newlines\n  str = str.replace(NEWLINES_RE, '\\n');\n\n  // Replace tabs with proper number of spaces (1..4)\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x5C/* \\ */:\n    case 0x60/* ` */:\n    case 0x2A/* * */:\n    case 0x5F/* _ */:\n    case 0x5E/* ^ */:\n    case 0x5B/* [ */:\n    case 0x5D/* ] */:\n    case 0x21/* ! */:\n    case 0x26/* & */:\n    case 0x3C/* < */:\n    case 0x3E/* > */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x40/* @ */:\n    case 0x7E/* ~ */:\n    case 0x2B/* + */:\n    case 0x3D/* = */:\n    case 0x3A/* : */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n}\n\n// Proceess '\\n'\n\nfunction newline(state, silent) {\n  var pmax, max, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Strip out all trailing spaces on this line.\n        for (var i = pmax - 2; i >= 0; i--) {\n          if (state.pending.charCodeAt(i) !== 0x20) {\n            state.pending = state.pending.substring(0, i + 1);\n            break;\n          }\n        }\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push({\n          type: 'softbreak',\n          level: state.level\n        });\n      }\n\n    } else {\n      state.push({\n        type: 'softbreak',\n        level: state.level\n      });\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  state.pos = pos;\n  return true;\n}\n\n// Proceess escaped chars and hardbreaks\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nfunction escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n}\n\n// Parse backticks\n\nfunction backticks(state, silent) {\n  var start, max, marker, matchStart, matchEnd,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        state.push({\n          type: 'code',\n          content: state.src.slice(pos, matchStart)\n                              .replace(/[ \\n]+/g, ' ')\n                              .trim(),\n          block: false,\n          level: state.level\n        });\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n}\n\n// Process ~~deleted text~~\n\nfunction del(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x7E/* ~ */) { return false; }\n  if (nextChar === 0x7E/* ~ */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }\n  if (pos > start + 3) {\n    // sequence of 4+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '~~'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '~~'\n            stack++;\n          } // else {\n            //  // standalone ' ~~ ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'del_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'del_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ++inserted text++\n\nfunction ins(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '++'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '++'\n            stack++;\n          } // else {\n            //  // standalone ' ++ ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'ins_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'ins_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ==highlighted text==\n\nfunction mark(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x3D/* = */) { return false; }\n  if (nextChar === 0x3D/* = */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '=='\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '=='\n            stack++;\n          } // else {\n            //  // standalone ' == ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'mark_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'mark_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process *this* and _that_\n\nfunction isAlphaNum(code) {\n  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||\n         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||\n         (code >= 0x61 /* a */ && code <= 0x7A /* z */);\n}\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n  if (pos >= max) { can_open = false; }\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n    // check whitespace conditions\n    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }\n    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }\n\n    if (marker === 0x5F /* _ */) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) { can_open = false; }\n      if (isAlphaNum(nextChar)) { can_close = false; }\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nfunction emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    if (!silent) { state.pending += state.src.slice(start, state.pos); }\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + startCount;\n  stack = [ startCount ];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n\n          if (stack.length === 0) { break; }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack.push(count); }\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_open', level: state.level++ });\n    }\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_open', level: state.level++ });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_close', level: --state.level });\n    }\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_close', level: --state.level });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n}\n\n// Process ~subscript~\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sub(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 2 >= max) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n      found = true;\n      break;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sub',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process ^superscript^\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE$1 = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sup(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 2 >= max) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {\n      found = true;\n      break;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE$1, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process [links](<to> \"stuff\")\n\n\nfunction links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21/* ! */) {\n    isImage = true;\n    marker = state.src.charCodeAt(++start);\n  }\n\n  if (marker !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    if (parseLinkDestination(state, pos)) {\n      href = state.linkContent;\n      pos = state.pos;\n    } else {\n      href = '';\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n      title = state.linkContent;\n      pos = state.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (code !== 0x20 && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n\n    // do not allow nested reference links\n    if (state.linkLevel > 0) { return false; }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = start - 1;\n      }\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({ type: 'link_close', level: --state.level });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// Process inline footnotes (^[...])\n\n\nfunction footnote_inline(state, silent) {\n  var labelStart,\n      labelEnd,\n      footnoteId,\n      oldLength,\n      max = state.posMax,\n      start = state.pos;\n\n  if (start + 2 >= max) { return false; }\n  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 2;\n  labelEnd = parseLinkLabel(state, start + 1);\n\n  // parser failed to find ']', so it's not a valid note\n  if (labelEnd < 0) { return false; }\n\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\n    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n    footnoteId = state.env.footnotes.list.length;\n\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      level: state.level\n    });\n    state.linkLevel++;\n    oldLength = state.tokens.length;\n    state.parser.tokenize(state);\n    state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };\n    state.linkLevel--;\n  }\n\n  state.pos = labelEnd + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process footnote references ([^...])\n\nfunction footnote_ref(state, silent) {\n  var label,\n      pos,\n      footnoteId,\n      footnoteSubId,\n      max = state.posMax,\n      start = state.pos;\n\n  // should be at least 4 chars - \"[^x]\"\n  if (start + 3 > max) { return false; }\n\n  if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) { return false; }\n    if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n\n  if (pos === start + 2) { return false; } // no empty footnote labels\n  if (pos >= max) { return false; }\n  pos++;\n\n  label = state.src.slice(start + 2, pos - 1);\n  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n  if (!silent) {\n    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n    if (state.env.footnotes.refs[':' + label] < 0) {\n      footnoteId = state.env.footnotes.list.length;\n      state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n      state.env.footnotes.refs[':' + label] = footnoteId;\n    } else {\n      footnoteId = state.env.footnotes.refs[':' + label];\n    }\n\n    footnoteSubId = state.env.footnotes.list[footnoteId].count;\n    state.env.footnotes.list[footnoteId].count++;\n\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      subId: footnoteSubId,\n      level: state.level\n    });\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// List of valid url schemas, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#autolinks\n\nvar url_schemas = [\n  'coap',\n  'doi',\n  'javascript',\n  'aaa',\n  'aaas',\n  'about',\n  'acap',\n  'cap',\n  'cid',\n  'crid',\n  'data',\n  'dav',\n  'dict',\n  'dns',\n  'file',\n  'ftp',\n  'geo',\n  'go',\n  'gopher',\n  'h323',\n  'http',\n  'https',\n  'iax',\n  'icap',\n  'im',\n  'imap',\n  'info',\n  'ipp',\n  'iris',\n  'iris.beep',\n  'iris.xpc',\n  'iris.xpcs',\n  'iris.lwz',\n  'ldap',\n  'mailto',\n  'mid',\n  'msrp',\n  'msrps',\n  'mtqp',\n  'mupdate',\n  'news',\n  'nfs',\n  'ni',\n  'nih',\n  'nntp',\n  'opaquelocktoken',\n  'pop',\n  'pres',\n  'rtsp',\n  'service',\n  'session',\n  'shttp',\n  'sieve',\n  'sip',\n  'sips',\n  'sms',\n  'snmp',\n  'soap.beep',\n  'soap.beeps',\n  'tag',\n  'tel',\n  'telnet',\n  'tftp',\n  'thismessage',\n  'tn3270',\n  'tip',\n  'tv',\n  'urn',\n  'vemmi',\n  'ws',\n  'wss',\n  'xcon',\n  'xcon-userid',\n  'xmlrpc.beep',\n  'xmlrpc.beeps',\n  'xmpp',\n  'z39.50r',\n  'z39.50s',\n  'adiumxtra',\n  'afp',\n  'afs',\n  'aim',\n  'apt',\n  'attachment',\n  'aw',\n  'beshare',\n  'bitcoin',\n  'bolo',\n  'callto',\n  'chrome',\n  'chrome-extension',\n  'com-eventbrite-attendee',\n  'content',\n  'cvs',\n  'dlna-playsingle',\n  'dlna-playcontainer',\n  'dtn',\n  'dvb',\n  'ed2k',\n  'facetime',\n  'feed',\n  'finger',\n  'fish',\n  'gg',\n  'git',\n  'gizmoproject',\n  'gtalk',\n  'hcp',\n  'icon',\n  'ipn',\n  'irc',\n  'irc6',\n  'ircs',\n  'itms',\n  'jar',\n  'jms',\n  'keyparc',\n  'lastfm',\n  'ldaps',\n  'magnet',\n  'maps',\n  'market',\n  'message',\n  'mms',\n  'ms-help',\n  'msnim',\n  'mumble',\n  'mvn',\n  'notes',\n  'oid',\n  'palm',\n  'paparazzi',\n  'platform',\n  'proxy',\n  'psyc',\n  'query',\n  'res',\n  'resource',\n  'rmi',\n  'rsync',\n  'rtmp',\n  'secondlife',\n  'sftp',\n  'sgn',\n  'skype',\n  'smb',\n  'soldat',\n  'spotify',\n  'ssh',\n  'steam',\n  'svn',\n  'teamspeak',\n  'things',\n  'udp',\n  'unreal',\n  'ut2004',\n  'ventrilo',\n  'view-source',\n  'webcal',\n  'wtai',\n  'wyciwyg',\n  'xfire',\n  'xri',\n  'ymsgr'\n];\n\n// Process autolinks '<protocol:...>'\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\n\n\nfunction autolink(state, silent) {\n  var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) { return false; }\n\n  linkMatch = tail.match(AUTOLINK_RE);\n\n  if (linkMatch) {\n    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = normalizeLink(url);\n    if (!state.parser.validateLink(url)) { return false; }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({ type: 'link_close', level: state.level });\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  emailMatch = tail.match(EMAIL_RE);\n\n  if (emailMatch) {\n\n    url = emailMatch[0].slice(1, -1);\n\n    fullUrl = normalizeLink('mailto:' + url);\n    if (!state.parser.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({ type: 'link_close', level: state.level });\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n}\n\n// Regexps to match html elements\n\nfunction replace$1(regex, options) {\n  regex = regex.source;\n  options = options || '';\n\n  return function self(name, val) {\n    if (!name) {\n      return new RegExp(regex, options);\n    }\n    val = val.source || val;\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\n\nvar attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;\n\nvar unquoted      = /[^\"'=<>`\\x00-\\x20]+/;\nvar single_quoted = /'[^']*'/;\nvar double_quoted = /\"[^\"]*\"/;\n\n/*eslint no-spaced-func:0*/\nvar attr_value  = replace$1(/(?:unquoted|single_quoted|double_quoted)/)\n                    ('unquoted', unquoted)\n                    ('single_quoted', single_quoted)\n                    ('double_quoted', double_quoted)\n                    ();\n\nvar attribute   = replace$1(/(?:\\s+attr_name(?:\\s*=\\s*attr_value)?)/)\n                    ('attr_name', attr_name)\n                    ('attr_value', attr_value)\n                    ();\n\nvar open_tag    = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\\s*\\/?>/)\n                    ('attribute', attribute)\n                    ();\n\nvar close_tag   = /<\\/[A-Za-z][A-Za-z0-9]*\\s*>/;\nvar comment     = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar processing  = /<[?].*?[?]>/;\nvar declaration = /<![A-Z]+\\s+[^>]*>/;\nvar cdata       = /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/;\n\nvar HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)\n  ('open_tag', open_tag)\n  ('close_tag', close_tag)\n  ('comment', comment)\n  ('processing', processing)\n  ('declaration', declaration)\n  ('cdata', cdata)\n  ();\n\n// Process html tags\n\n\nfunction isLetter$2(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nfunction htmltag(state, silent) {\n  var ch, match, max, pos = state.pos;\n\n  if (!state.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter$2(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    state.push({\n      type: 'htmltag',\n      content: state.src.slice(pos, pos + match[0].length),\n      level: state.level\n    });\n  }\n  state.pos += match[0].length;\n  return true;\n}\n\n// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nfunction entity(state, silent) {\n  var ch, code, match, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        var decoded = decodeEntity(match[1]);\n        if (match[1] !== decoded) {\n          if (!silent) { state.pending += decoded; }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) { state.pending += '&'; }\n  state.pos++;\n  return true;\n}\n\n/**\n * Inline Parser `rules`\n */\n\nvar _rules$2 = [\n  [ 'text',            text ],\n  [ 'newline',         newline ],\n  [ 'escape',          escape ],\n  [ 'backticks',       backticks ],\n  [ 'del',             del ],\n  [ 'ins',             ins ],\n  [ 'mark',            mark ],\n  [ 'emphasis',        emphasis ],\n  [ 'sub',             sub ],\n  [ 'sup',             sup ],\n  [ 'links',           links ],\n  [ 'footnote_inline', footnote_inline ],\n  [ 'footnote_ref',    footnote_ref ],\n  [ 'autolink',        autolink ],\n  [ 'htmltag',         htmltag ],\n  [ 'entity',          entity ]\n];\n\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$2.length; i++) {\n    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n  }\n\n  // Can be overridden with a custom validator\n  this.validateLink = validateLink;\n}\n\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n\n  while (state.pos < end) {\n\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n\n      if (ok) {\n        break;\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];\n  var str = url.trim().toLowerCase();\n  // Care about digital entities \"javascript&#x3A;alert(1)\"\n  str = replaceEntities(str);\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n  return true;\n}\n\n// Remarkable default options\n\nvar defaultConfig = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'block',\n        'inline',\n        'references',\n        'replacements',\n        'smartquotes',\n        'references',\n        'abbr2',\n        'footnote_tail'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fences',\n        'footnote',\n        'heading',\n        'hr',\n        'htmlblock',\n        'lheading',\n        'list',\n        'paragraph',\n        'table'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'del',\n        'emphasis',\n        'entity',\n        'escape',\n        'footnote_ref',\n        'htmltag',\n        'links',\n        'newline',\n        'text'\n      ]\n    }\n  }\n};\n\n// Remarkable default options\n\nvar fullConfig = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes:       '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight:     null,\n\n    maxNesting:    20            // Internal protection, recursion limit\n  },\n\n  components: {\n    // Don't restrict core/block/inline rules\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n\n// Commonmark default options\n\nvar commonmarkConfig = {\n  options: {\n    html:         true,         // Enable HTML tags in source\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'block',\n        'inline',\n        'references',\n        'abbr2'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fences',\n        'heading',\n        'hr',\n        'htmlblock',\n        'lheading',\n        'list',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'htmltag',\n        'links',\n        'newline',\n        'text'\n      ]\n    }\n  }\n};\n\n/**\n * Preset configs\n */\n\nvar config = {\n  'default': defaultConfig,\n  'full': fullConfig,\n  'commonmark': commonmarkConfig\n};\n\n/**\n * The `StateCore` class manages state.\n *\n * @param {Object} `instance` Remarkable instance\n * @param {String} `str` Markdown string\n * @param {Object} `env`\n */\n\nfunction StateCore(instance, str, env) {\n  this.src = str;\n  this.env = env;\n  this.options = instance.options;\n  this.tokens = [];\n  this.inlineMode = false;\n\n  this.inline = instance.inline;\n  this.block = instance.block;\n  this.renderer = instance.renderer;\n  this.typographer = instance.typographer;\n}\n\n/**\n * The main `Remarkable` class. Create an instance of\n * `Remarkable` with a `preset` and/or `options`.\n *\n * @param {String} `preset` If no preset is given, `default` is used.\n * @param {Object} `options`\n */\n\nfunction Remarkable(preset, options) {\n  if (typeof preset !== 'string') {\n    options = preset;\n    preset = 'default';\n  }\n\n  if (options && options.linkify != null) {\n    console.warn(\n      'linkify option is removed. Use linkify plugin instead:\\n\\n' +\n      'import Remarkable from \\'remarkable\\';\\n' +\n      'import linkify from \\'remarkable/linkify\\';\\n' +\n      'new Remarkable().use(linkify)\\n'\n    );\n  }\n\n  this.inline   = new ParserInline();\n  this.block    = new ParserBlock();\n  this.core     = new Core();\n  this.renderer = new Renderer();\n  this.ruler    = new Ruler();\n\n  this.options  = {};\n  this.configure(config[preset]);\n  this.set(options || {});\n}\n\n/**\n * Set options as an alternative to passing them\n * to the constructor.\n *\n * ```js\n * md.set({typographer: true});\n * ```\n * @param {Object} `options`\n * @api public\n */\n\nRemarkable.prototype.set = function (options) {\n  assign(this.options, options);\n};\n\n/**\n * Batch loader for components rules states, and options\n *\n * @param  {Object} `presets`\n */\n\nRemarkable.prototype.configure = function (presets) {\n  var self = this;\n\n  if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }\n  if (presets.options) { self.set(presets.options); }\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enable(presets.components[name].rules, true);\n      }\n    });\n  }\n};\n\n/**\n * Use a plugin.\n *\n * ```js\n * var md = new Remarkable();\n *\n * md.use(plugin1)\n *   .use(plugin2, opts)\n *   .use(plugin3);\n * ```\n *\n * @param  {Function} `plugin`\n * @param  {Object} `options`\n * @return {Object} `Remarkable` for chaining\n */\n\nRemarkable.prototype.use = function (plugin, options) {\n  plugin(this, options);\n  return this;\n};\n\n\n/**\n * Parse the input `string` and return a tokens array.\n * Modifies `env` with definitions data.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parse = function (str, env) {\n  var state = new StateCore(this, str, env);\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * The main `.render()` method that does all the magic :)\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {String} Rendered HTML.\n */\n\nRemarkable.prototype.render = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parse(str, env), this.options, env);\n};\n\n/**\n * Parse the given content `string` as a single string.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parseInline = function (str, env) {\n  var state = new StateCore(this, str, env);\n  state.inlineMode = true;\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * Render a single content `string`, without wrapping it\n * to paragraphs\n *\n * @param  {String} `str`\n * @param  {Object} `env`\n * @return {String}\n */\n\nRemarkable.prototype.renderInline = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parseInline(str, env), this.options, env);\n};\n\nexport { Remarkable, utils };\n","/* eslint-disable prettier/prettier */\nimport { Remarkable } from 'remarkable';\n\nexport default {\n  name: 'vue-remarkable',\n  props: {\n    options: {\n      type: Object,\n      default: () => {}\n    },\n    className: {\n      type: String\n    },\n    source: {\n      type: String\n    },\n    container: {\n      type: String,\n      default: 'div'\n    }\n  },\n  data() {\n    return {\n      md: undefined\n    };\n  },\n  methods: {\n    content () {\n      if (this.source) {\n        return <span domPropsInnerHTML={this.renderMarkdown(this.source.trim())} />\n      } else {\n        if (this.$slots.default) {\n          const textChildren = this.$slots.default.filter(s => s.tag == undefined)\n          const markdownSlotText = textChildren.reduce((acc, current) => {\n            const { text } = current\n            acc += '\\n' + text.trim()\n            return acc\n          }, '')\n          return <span domPropsInnerHTML={this.renderMarkdown(markdownSlotText)} />\n        }\n      }\n    },\n    renderMarkdown(source) {\n      if (!this.md) {\n        this.md = new Remarkable(this.options);\n      }\n  \n      return this.md.render(source);\n    }\n  },\n  render () {\n    const Container = this.container;\n\n    return (\n      <Container class={this.className}>\n        {this.content()}\n      </Container>\n    )\n  }\n}","import './setPublicPath'\nimport mod from '~entry'\nexport default mod\nexport * from '~entry'\n"],"sourceRoot":""}